<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 实现Promise.all 以及 race
      Promise.myall = function(arr) {
        return new Promise((resolve, reject) => {
          if (arr.length === 0) {
            return resolve([]);
          } else {
            let res = [],
              count = 0;
            for (let i = 0; i < arr.length; i++) {
              // 同时也能处理arr数组中非Promise对象
              if (!(arr[i] instanceof Promise)) {
                res[i] = arr[i];
                if (++count === arr.length) resolve(res);
              } else {
                arr[i].then(
                  data => {
                    res[i] = data;
                    if (++count === arr.length) resolve(res);
                  },
                  err => {
                    reject(err);
                  }
                );
              }
            }
          }
        });
      };

      Promise.myrace = function(arr) {
        return new Promise((resolve, reject) => {
          for (let i = 0; i < arr.length; i++) {
            // 同时也能处理arr数组中非Promise对象
            if (!(arr[i] instanceof Promise)) {
              Promise.resolve(arr[i]).then(resolve, reject);
            } else {
              arr[i].then(resolve, reject);
            }
          }
        });
      };

      function Promise2(callback) {
        this.status = "pending";
        this.data = null;
        this.reason = null;
        this.resolveCb = [];
        this.rejectCb = [];

        function resolve(data) {
          if (this.status === "pending") {
            this.data = data;
            this.status = "fulfilled";
            this.resolveCb.forEach(cb => cb(data));
          }
        }

        function reject(reason) {
          if (this.status === "pending") {
            this.reason = reason;
            this.status = "rejected";
            this.rejectCb.forEach(cb => cb(reason));
          }
        }

        try {
          callback(resolve, reject);
        } catch (error) {
          reject(error);
        }
      }

      Promise2.prototype.then = function(onResolve, onReject) {
        if (this.status == "fulfilled") {
          onResolve(this.data);
        }

        if (this.status == "rejected") {
          onReject(this.reason);
        }
        if (this.status == "pending") {
          this.resolveCb.push(() => onResolve(this.data));
          this.rejectCb.push(() => onReject(this.reason));
        }
      };

      Promise2.prototype.all = function(arr) {
        return new Promise2((resolve, reject) => {
          let result = [];
          let count = 0;
          arr.forEach((p, i) => {
            p.then(res => {
              result[i] = res;
              count++;
              if (count === arr.length) {
                resolve(values);
              }
            }).catch(reject);
          });
        });
      };

      // koa

      function compose(middleware) {

        return function (context,next) {

          let index = -1
          return dispatch(0)

          function dispatch(i) {
            if(i< index) return
            index = i
            let fn = middleware[i]
            if(i == middleware.length) fn = next

            if(!fn) return Promise.resolve()

            try {
              return Promise.resolve(fn(context, dispatch.bind(null, i+1)));
            } catch (error) {
              return Promise.reject(error)
            }
          }
        }
      }

      function compose(middleware) {
        function dispatch(index) {
          if (index === middleware.length) return Promise.resolve();

          let fn = middleware[index];

          return Promise.resolve(fn(() => dispatch(index + 1)));
        }
        dispatch(0);
      }

      // redux compose
      export default function compose(...funcs) {
        if (funcs.length === 0) {
          return arg => arg;
        }

        if (funcs.length === 1) {
          return funcs[0];
        }

        return funcs.reduce((a, b) => (...args) => a(b(...args)));
      }

      //
      function requestPools(tasks, max = 5) {
        let result = [];

        let pools = new Array(max).fill(null);
        let index = 0;

        pools.map(pol => {
          return new Promise((resolve, reject) => {
            let next = function name(params) {
              if (index >= tasks.length) {
                resolve(result);
                return;
              }
              let old = index;
              let task = task[index++];
              task()
                .then(res => {
                  result[old] = res;
                  next();
                })
                .catch(err => reject(err));
            };

            next();
          });
        });

        return Promise.all(pools).then(() => result);
      }
    </script>
  </body>
</html>
